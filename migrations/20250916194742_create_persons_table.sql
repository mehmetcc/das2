-- +goose Up
-- Enable UUID generation
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Base table
CREATE TABLE IF NOT EXISTS persons (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  public_id    UUID        NOT NULL DEFAULT gen_random_uuid(),
  email        TEXT        NOT NULL,
  username     TEXT        NOT NULL,
  password     TEXT        NOT NULL,
  role         TEXT        NOT NULL DEFAULT 'user' CHECK (role IN ('user','admin')),
  is_active    BOOLEAN     NOT NULL DEFAULT FALSE,
  is_deleted   BOOLEAN     NOT NULL DEFAULT FALSE,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Normalize emails if any existing rows
UPDATE persons SET email = lower(email);

-- Keep email stored in lowercase (defense in depth)
ALTER TABLE persons
  DROP CONSTRAINT IF EXISTS email_lower,
  ADD CONSTRAINT email_lower CHECK (email = lower(email));

-- Uniqueness
CREATE UNIQUE INDEX IF NOT EXISTS persons_email_key    ON persons (lower(email)); -- case-insensitive
CREATE UNIQUE INDEX IF NOT EXISTS persons_username_key ON persons (username);

-- updated_at auto-touch trigger
-- +goose StatementBegin
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
-- +goose StatementEnd

DROP TRIGGER IF EXISTS trg_persons_updated_at ON persons;
CREATE TRIGGER trg_persons_updated_at
BEFORE UPDATE ON persons
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- created_at: force now() on INSERT (ignore client) and make it immutable on UPDATE
-- +goose StatementBegin
CREATE OR REPLACE FUNCTION force_created_at_on_insert()
RETURNS trigger AS $$
BEGIN
  NEW.created_at := now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
-- +goose StatementEnd

DROP TRIGGER IF EXISTS trg_persons_created_at_on_insert ON persons;
CREATE TRIGGER trg_persons_created_at_on_insert
BEFORE INSERT ON persons
FOR EACH ROW
EXECUTE FUNCTION force_created_at_on_insert();

-- +goose StatementBegin
CREATE OR REPLACE FUNCTION lock_created_at_on_update()
RETURNS trigger AS $$
BEGIN
  IF NEW.created_at IS DISTINCT FROM OLD.created_at THEN
    RAISE EXCEPTION 'created_at is immutable';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
-- +goose StatementEnd

DROP TRIGGER IF EXISTS trg_persons_created_at_immutable ON persons;
CREATE TRIGGER trg_persons_created_at_immutable
BEFORE UPDATE ON persons
FOR EACH ROW
EXECUTE FUNCTION lock_created_at_on_update();

-- +goose Down
DROP TRIGGER IF EXISTS trg_persons_created_at_immutable ON persons;
DROP TRIGGER IF EXISTS trg_persons_created_at_on_insert ON persons;
DROP TRIGGER IF EXISTS trg_persons_updated_at ON persons;

DROP FUNCTION IF EXISTS lock_created_at_on_update();
DROP FUNCTION IF EXISTS force_created_at_on_insert();
DROP FUNCTION IF EXISTS set_updated_at();

ALTER TABLE persons DROP CONSTRAINT IF EXISTS email_lower;

DROP INDEX IF EXISTS persons_username_key;
DROP INDEX IF EXISTS persons_email_key;

DROP TABLE IF EXISTS persons;

DROP EXTENSION IF EXISTS pgcrypto;
